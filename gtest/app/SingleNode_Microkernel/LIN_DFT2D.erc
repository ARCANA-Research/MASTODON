// Perform 2d DFT : FxIxF_T where F is the DFT matrix, I is the input image, F_T is the transposed DFT matrix

#define output 128
for (regfile = 0; regfile < 64; regfile += 1)
	COMPUTE 0 [regfile]
	COMPUTE 1 [regfile]
for (addr = 0; addr < 64; addr += 1)
	MUL32 [addr] [addr + 64] [addr + 64]
endfor
INIT0 [output]
for (addr = 64; addr < 128; addr += 1)
	ADD [output] [addr] [output]
endfor
COMPUTE_DONE
FLUSH
endfor

MOVE 0 2
MOVE 1 3
	for (src_regfile = 0; src_regfile < 64; src_regfile += 1)
		for (des_regfile = 0; des_regfile < 64; des_regfile += 1)
			MEM_COPY_RSHIFT [src_regfile] [output] 16 [des_regfile] [src_regfile]
		endfor
	endfor
MOVE_DONE

for (regfile = 0; regfile < 64; regfile += 1)
	COMPUTE 2 [regfile]
	COMPUTE 3 [regfile]
for (addr = 0; addr < 64; addr += 1)
	MUL32 [addr] [addr + 64] [addr + 64]
endfor
INIT0 [output]
for (addr = 64; addr < 128; addr += 1)
	ADD [output] [addr] [output]
endfor
COMPUTE_DONE
FLUSH
endfor

MOVE 2 4
	for (src_regfile = 0; src_regfile < 64; src_regfile += 1)
		MEM_COPY [src_regfile] [output] 0 [src_regfile]
	endfor
MOVE_DONE

MOVE 3 4
	for (src_regfile = 0; src_regfile < 64; src_regfile += 1)
		MEM_COPY [src_regfile] [output] 0 [src_regfile + 64]
	endfor
MOVE_DONE

COMPUTE 4 0
	for (addr = 0; addr < 64; addr += 1)
		//DINV [addr + 64]
		//INC [addr + 64] [addr + 64]
		SUB [addr] [addr + 64] [addr]
	endfor
COMPUTE_DONE
FLUSH
EOF

